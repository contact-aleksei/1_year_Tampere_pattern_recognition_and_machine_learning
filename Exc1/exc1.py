# -*- coding: utf-8 -*-
"""
Created on Tue Oct 29 12:11:33 2019

@author: OWNER
PATTERN RECOGNITION'
"""
# %%


"""FIRST TASK"""
from scipy.io import loadmat
import matplotlib.pyplot as plt

mat = loadmat("twoClassData.mat")

print(mat.keys()) 
X = mat["X"] 
y = mat["y"].ravel()
"""The function ravel() transforms y from 400 × 1 matrix into a 400-length
array"""

class_1=X[y == 0, :]
class_2=X[y == 1, :]

plt.plot(class_1[:, 0], class_1[:, 1], 'ro')
plt.plot(class_2[:, 0], class_2[:, 1], 'bo')
plt.show()

# %%
"""SECOND TASK"""
import matplotlib.pyplot as plt
from matplotlib.image import imread
import numpy as np

# Read the data

img = imread("uneven_illumination.jpg")
plt.imshow(img, cmap='gray')
plt.title("Image shape is %dx%d" % (img.shape[1], img.shape[0]))
plt.show()

# Create the X-Y coordinate pairs in a matrix
X, Y = np.meshgrid(range(1300), range(1030))
Z = img

#b) Vectorize the matrices X, Y,Z using ravel, e.g., z = Z.ravel().
x = X.ravel()
y = Y.ravel()
z = Z.ravel()
"********* TODO 1 ********** "
# Create data matrix
# Use function "np.column_stack".
# Function "np.ones_like" creates a vector like the input.'
H = np.column_stack((x**2,y**2,x*y,x,y,np.ones((z.size))))

" ********* TODO 2 ********** "
# Solve coefficients
# Use np.linalg.lstsq
# Put coefficients to variable "theta" which we use below.
theta = np.linalg.inv(H.transpose() @ H) @ H.transpose() @ z

# Predict
#d) Compute the model prediction as z_pred = np.dot(H, c) and resize
#the vector to the original size
z_pred = H @ theta
Z_pred = np.reshape(z_pred, X.shape)

# Subtract & show
#e) Subtract the model prediction from the original image and show the result
#on screen.
S = Z - Z_pred
plt.imshow(Z_pred, cmap = 'gray')
plt.show()
plt.imshow(S, cmap = 'gray')
plt.show()

# %%
"""Estimate sinusoidal parameters"""
"TASK3"
import numpy as np

#a) Generate a 100-sample long synthetic test signal from the model:
#x[n] = sin (2πf0n) + w[n], n = 0, 1, . . . , 99
#with f0 = 0.015 and w[n] ∼ N (0, 0.3). Note that w[n] is generated by
#w = numpy.sqrt(0.3) * numpy.random.randn(100). Plot the result.
n = np.linspace(0,99,100)
#Returns num evenly spaced samples, calculated over the interval [start, stop].
#numpy.linspace(start, stop, num=50,.........
f0 = 0.015
sinus = np.sin(2*np.pi*f0*n)
w = np.sqrt(0.3) * np.random.randn(100)
x = sinus + w
plt.plot(n,x)
plt.show()


scores = []
frequencies = []
for f in np.linspace(0, 0.5, 1000):
    # Create vector e. Assume data is in x.
    n = np.arange(100)
    
    # <compute -2*pi*i*f*n. Imaginary unit is 1j>
    z = -2*np.pi*1j*f*n
    e = np.exp(z)
    
    score = np.abs(np.dot(x,e))
    # <compute abs of dot product of x and e>
    
    scores.append(score)
    
    frequencies.append(f)
    
fHat = frequencies[np.argmax(scores)]
print(fHat)


import scipy
import numpy as np
A=np.array([[1 ,0.5],[0.5 ,1 ]])
B=np.linalg.cholesky(A)

